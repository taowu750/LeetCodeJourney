package acguide._0x00_basicalgorithm._0x07_greedy;

import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.TreeMap;
import java.util.function.ToIntBiFunction;

import static org.junit.jupiter.api.Assertions.assertEquals;

/**
 * Sunscreen: https://www.acwing.com/problem/content/112/
 *
 * 有 C 头奶牛进行日光浴，第 i 头奶牛需要 minSPF[i] 到 maxSPF[i] 单位强度之间的阳光。
 *
 * 每头奶牛在日光浴前必须涂防晒霜，防晒霜有 L 种，涂上第 i 种之后，身体接收到的阳光强度就会稳定为 SPF[i]，
 * 第 i 种防晒霜有 cover[i] 瓶。
 *
 * 求最多可以满足多少头奶牛进行日光浴。
 *
 * 例 1：
 * 输入：
 * min&maxSPF=[[3,10],[2,5],[1,5]]], SPF&cover=[[6,2],[4,1]]
 * 输出：
 * 2
 *
 * 说明：
 * - 1 ≤ C,L ≤ 2500,
 * - 1 ≤ minSPF ≤ maxSPF ≤ 1000,
 * - 1 ≤ SPF ≤ 1000
 */
public class G025_Sunscreen {

    public static void test(ToIntBiFunction<int[][], int[][]> method) {
        assertEquals(2, method.applyAsInt(new int[][]{{3,10},{2,5},{1,5}}, new int[][]{{6,2},{4,1}}));
        assertEquals(98, method.applyAsInt(new int[][]{{671, 910}, {224, 352}, {203, 429}, {804, 927}, {321, 513}, {23, 766}, {457, 501}, {455, 980}, {622, 905}, {530, 566}, {191, 730}, {17, 730}, {183, 705}, {227, 554}, {168, 188}, {369, 411}, {119, 730}, {11, 852}, {439, 895}, {250, 729}, {448, 608}, {731, 973}, {292, 702}, {432, 440}, {185, 423}, {628, 743}, {18, 861}, {290, 647}, {481, 974}, {156, 614}, {224, 549}, {509, 689}, {79, 123}, {83, 614}, {76, 731}, {171, 681}, {414, 486}, {457, 522}, {152, 516}, {586, 824}, {490, 594}, {264, 872}, {258, 388}, {102, 914}, {151, 862}, {401, 981}, {294, 846}, {132, 457}, {210, 596}, {311, 335}, {333, 452}, {235, 362}, {93, 332}, {472, 731}, {179, 393}, {272, 626}, {327, 421}, {121, 663}, {147, 748}, {49, 927}, {212, 352}, {181, 387}, {529, 688}, {574, 666}, {103, 903}, {112, 350}, {293, 744}, {159, 561}, {500, 986}, {60, 560}, {615, 787}, {719, 879}, {118, 770}, {41, 923}, {308, 790}, {168, 361}, {494, 557}, {216, 874}, {645, 992}, {172, 293}, {58, 512}, {212, 404}, {245, 726}, {27, 649}, {635, 871}, {251, 399}, {260, 931}, {122, 141}, {169, 727}, {517, 685}, {875, 884}, {37, 70}, {512, 937}, {237, 333}, {74, 292}, {349, 802}, {619, 663}, {349, 881}, {7, 252}, {24, 544}},
                new int[][]{{482, 1}, {532, 1}, {248, 1}, {960, 1}, {583, 1}, {721, 1}, {810, 1}, {19, 1}, {771, 1}, {962, 1}, {452, 1}, {63, 1}, {393, 1}, {165, 1}, {276, 1}, {282, 1}, {846, 1}, {458, 1}, {573, 1}, {637, 1}, {760, 1}, {108, 1}, {448, 1}, {65, 1}, {707, 1}, {875, 1}, {572, 1}, {643, 1}, {564, 1}, {417, 1}, {201, 1}, {788, 1}, {169, 1}, {170, 1}, {537, 1}, {852, 1}, {640, 1}, {503, 1}, {320, 1}, {864, 1}, {80, 1}, {380, 1}, {301, 1}, {337, 1}, {566, 1}, {337, 1}, {330, 1}, {888, 1}, {152, 1}, {110, 1}, {881, 1}, {119, 1}, {15, 1}, {770, 1}, {47, 1}, {137, 1}, {760, 1}, {558, 1}, {142, 1}, {220, 1}, {899, 1}, {581, 1}, {301, 1}, {486, 1}, {113, 1}, {567, 1}, {338, 1}, {438, 1}, {63, 1}, {686, 1}, {211, 1}, {493, 1}, {936, 1}, {544, 1}, {137, 1}, {588, 1}, {2, 1}, {839, 1}, {335, 1}, {503, 1}, {767, 1}, {238, 1}, {114, 1}, {699, 1}, {447, 1}, {573, 1}, {368, 1}, {844, 1}, {668, 1}, {774, 1}, {198, 1}, {754, 1}, {422, 1}, {320, 1}, {253, 1}, {901, 1}, {640, 1}, {859, 1}, {596, 1}, {6, 1}}));
    }

    public int sunscreen(int[][] cows, int[][] spfs) {
        /*
        对奶牛按照 minSPF 降序排序，对每个奶牛 c，优先从最大的 spf 看能不能满足它，可以的话就选，否则就找小一点的
         */

        Arrays.sort(cows, (a, b) -> -Integer.compare(a[0], b[0]));
        TreeMap<Integer, Integer> tree = new TreeMap<>();
        for (int[] spf : spfs) {
            // 注意可能有重复的防晒值
            tree.merge(spf[0], spf[1], Integer::sum);
        }

        int ans = 0;
        for (int[] cow : cows) {
            Integer floor = tree.floorKey(cow[1]);
            if (floor != null && floor >= cow[0]) {
                tree.merge(floor, -1, (old, delta) -> {
                    if (old + delta == 0) {
                        return null;
                    } else {
                        return old + delta;
                    }
                });
                ans++;
            }
        }

        return ans;
    }

    @Test
    public void testSunscreen() {
        test(this::sunscreen);
    }
}
